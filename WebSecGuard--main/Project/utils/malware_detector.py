#!/usr/bin/env python3
"""
Malware Detection Utility for WebSecGuard
Advanced malware detection using signatures and behavioral analysis
"""

import hashlib
import re
import json
import sqlite3
import os
from datetime import datetime
from typing import Dict, List, Optional
import random

class MalwareDetector:
    """Advanced malware detection system"""
    
    def __init__(self, db_path="malware_data.db"):
        self.db_path = db_path
        self.init_malware_database()
        
        # Malware signatures (simulated)
        self.malware_signatures = {
            'trojan_win32': {'hash': 'hash1', 'pattern': r'trojan', 'level': 'high'},
            'ransomware': {'hash': 'hash2', 'pattern': r'encrypt', 'level': 'critical'},
            'spyware': {'hash': 'hash3', 'pattern': r'keylog', 'level': 'high'}
        }
        
        # Known malicious hashes
        self.malicious_hashes = {
            'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855': 'trojan_sample',
            'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3': 'ransomware_sample'
        }
        
    def init_malware_database(self):
        """Initialize the malware database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS malware_scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT UNIQUE NOT NULL,
                target_path TEXT NOT NULL,
                scan_type TEXT NOT NULL,
                start_time TEXT NOT NULL,
                end_time TEXT,
                status TEXT DEFAULT 'running',
                files_scanned INTEGER DEFAULT 0,
                threats_found INTEGER DEFAULT 0,
                created_at TEXT NOT NULL
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS file_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                file_path TEXT NOT NULL,
                file_hash TEXT NOT NULL,
                file_size INTEGER,
                file_type TEXT,
                threat_level TEXT DEFAULT 'clean',
                threat_type TEXT,
                signature_matches TEXT,
                created_at TEXT NOT NULL
            )
        ''')
        
        conn.commit()
        conn.close()
        
    def scan_file(self, file_path: str) -> Dict:
        """Scan a single file for malware"""
        if not os.path.exists(file_path):
            return {'error': 'File not found'}
            
        results = {
            'file_path': file_path,
            'file_hash': self._calculate_file_hash(file_path),
            'file_size': os.path.getsize(file_path),
            'threat_level': 'clean',
            'threat_type': None,
            'signature_matches': [],
            'scan_time': datetime.now().isoformat()
        }
        
        # Check hash
        if results['file_hash'] in self.malicious_hashes:
            results['threat_level'] = 'high'
            results['threat_type'] = 'known_malware'
            results['signature_matches'].append(self.malicious_hashes[results['file_hash']])
            
        # Check patterns
        pattern_matches = self._scan_for_patterns(file_path)
        results['signature_matches'].extend(pattern_matches)
        
        if results['signature_matches']:
            results['threat_level'] = 'medium'
            
        return results
        
    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA-256 hash of file"""
        try:
            with open(file_path, 'rb') as f:
                return hashlib.sha256(f.read()).hexdigest()
        except:
            return ''
            
    def _scan_for_patterns(self, file_path: str) -> List[str]:
        """Scan file for suspicious patterns"""
        matches = []
        try:
            with open(file_path, 'rb') as f:
                content = f.read().decode('utf-8', errors='ignore')
                
            for name, sig in self.malware_signatures.items():
                if re.search(sig['pattern'], content, re.IGNORECASE):
                    matches.append(name)
        except:
            pass
        return matches
        
    def scan_directory(self, directory_path: str) -> str:
        """Scan a directory for malware"""
        scan_id = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO malware_scans 
            (scan_id, target_path, scan_type, start_time, created_at)
            VALUES (?, ?, ?, ?, ?)
        ''', (scan_id, directory_path, 'comprehensive', datetime.now().isoformat(), datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        # Simulate scan
        self._run_directory_scan(scan_id, directory_path)
        
        return scan_id
        
    def _run_directory_scan(self, scan_id: str, directory_path: str):
        """Run directory scan"""
        files_scanned = 0
        threats_found = 0
        
        for root, dirs, files in os.walk(directory_path):
            for file in files:
                file_path = os.path.join(root, file)
                scan_result = self.scan_file(file_path)
                files_scanned += 1
                
                if scan_result['threat_level'] != 'clean':
                    threats_found += 1
                    
                self._record_file_analysis(scan_id, scan_result)
                
        self._complete_scan(scan_id, files_scanned, threats_found)
        
    def _record_file_analysis(self, scan_id: str, scan_result: Dict):
        """Record file analysis"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO file_analysis 
            (scan_id, file_path, file_hash, file_size, threat_level, threat_type, signature_matches, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            scan_id, scan_result['file_path'], scan_result['file_hash'],
            scan_result['file_size'], scan_result['threat_level'],
            scan_result['threat_type'], json.dumps(scan_result['signature_matches']),
            datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
        
    def _complete_scan(self, scan_id: str, files_scanned: int, threats_found: int):
        """Complete scan"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE malware_scans 
            SET status = 'completed', end_time = ?, files_scanned = ?, threats_found = ?
            WHERE scan_id = ?
        ''', (datetime.now().isoformat(), files_scanned, threats_found, scan_id))
        
        conn.commit()
        conn.close()
        
    def get_scan_results(self, scan_id: str) -> Dict:
        """Get scan results"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT target_path, scan_type, start_time, end_time, status,
                   files_scanned, threats_found
            FROM malware_scans WHERE scan_id = ?
        ''', (scan_id,))
        
        scan_row = cursor.fetchone()
        if not scan_row:
            return {'error': 'Scan not found'}
            
        cursor.execute('''
            SELECT file_path, file_hash, threat_level, threat_type, signature_matches
            FROM file_analysis WHERE scan_id = ?
        ''', (scan_id,))
        
        files = []
        for row in cursor.fetchall():
            files.append({
                'file_path': row[0],
                'file_hash': row[1],
                'threat_level': row[2],
                'threat_type': row[3],
                'signature_matches': json.loads(row[4]) if row[4] else []
            })
            
        conn.close()
        
        return {
            'scan_id': scan_id,
            'target_path': scan_row[0],
            'scan_type': scan_row[1],
            'start_time': scan_row[2],
            'end_time': scan_row[3],
            'status': scan_row[4],
            'files_scanned': scan_row[5],
            'threats_found': scan_row[6],
            'files': files
        } 