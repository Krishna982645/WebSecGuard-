#!/usr/bin/env python3
"""
Vulnerability Scanner Utility for WebSecGuard
Advanced vulnerability detection and assessment
"""

import sqlite3
import json
import re
import socket
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import random
import urllib.parse

class VulnerabilityScanner:
    """Advanced vulnerability scanning system"""
    
    def __init__(self, db_path="vulnerability_data.db"):
        self.db_path = db_path
        self.init_vulnerability_database()
        
        # Common vulnerabilities
        self.vulnerability_types = {
            'sql_injection': {
                'severity': 'high',
                'description': 'SQL injection vulnerability',
                'cwe': 'CWE-89',
                'cvss_score': 9.8
            },
            'xss': {
                'severity': 'medium',
                'description': 'Cross-site scripting vulnerability',
                'cwe': 'CWE-79',
                'cvss_score': 6.1
            },
            'csrf': {
                'severity': 'medium',
                'description': 'Cross-site request forgery',
                'cwe': 'CWE-352',
                'cvss_score': 6.5
            },
            'open_redirect': {
                'severity': 'medium',
                'description': 'Open redirect vulnerability',
                'cwe': 'CWE-601',
                'cvss_score': 5.4
            },
            'weak_ssl': {
                'severity': 'high',
                'description': 'Weak SSL/TLS configuration',
                'cwe': 'CWE-327',
                'cvss_score': 7.5
            },
            'default_credentials': {
                'severity': 'high',
                'description': 'Default credentials in use',
                'cwe': 'CWE-1188',
                'cvss_score': 8.8
            },
            'outdated_software': {
                'severity': 'medium',
                'description': 'Outdated software version',
                'cwe': 'CWE-1104',
                'cvss_score': 5.5
            },
            'information_disclosure': {
                'severity': 'low',
                'description': 'Information disclosure',
                'cwe': 'CWE-200',
                'cvss_score': 3.1
            }
        }
        
        # Port vulnerabilities
        self.port_vulnerabilities = {
            21: ['ftp_anonymous', 'ftp_weak_auth'],
            22: ['ssh_weak_crypto', 'ssh_brute_force'],
            23: ['telnet_insecure'],
            25: ['smtp_open_relay', 'smtp_weak_auth'],
            53: ['dns_zone_transfer', 'dns_amplification'],
            80: ['http_information_disclosure', 'http_default_page'],
            443: ['ssl_weak_crypto', 'ssl_certificate_issues'],
            1433: ['mssql_weak_auth', 'mssql_default_sa'],
            3306: ['mysql_weak_auth', 'mysql_default_root'],
            3389: ['rdp_weak_auth', 'rdp_bluekeep'],
            5432: ['postgres_weak_auth', 'postgres_default_admin'],
            5900: ['vnc_weak_auth', 'vnc_no_encryption']
        }
        
    def init_vulnerability_database(self):
        """Initialize the vulnerability database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create vulnerability scans table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerability_scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT UNIQUE NOT NULL,
                target_url TEXT NOT NULL,
                scan_type TEXT NOT NULL,
                start_time TEXT NOT NULL,
                end_time TEXT,
                status TEXT DEFAULT 'running',
                vulnerabilities_found INTEGER DEFAULT 0,
                critical_count INTEGER DEFAULT 0,
                high_count INTEGER DEFAULT 0,
                medium_count INTEGER DEFAULT 0,
                low_count INTEGER DEFAULT 0,
                created_at TEXT NOT NULL
            )
        ''')
        
        # Create vulnerabilities table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                vulnerability_type TEXT NOT NULL,
                severity TEXT NOT NULL,
                cvss_score REAL,
                cwe_id TEXT,
                description TEXT,
                evidence TEXT,
                location TEXT,
                parameter TEXT,
                payload TEXT,
                remediation TEXT,
                false_positive BOOLEAN DEFAULT FALSE,
                verified BOOLEAN DEFAULT FALSE,
                created_at TEXT NOT NULL,
                FOREIGN KEY (scan_id) REFERENCES vulnerability_scans (scan_id)
            )
        ''')
        
        # Create CVE database table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cve_database (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cve_id TEXT UNIQUE NOT NULL,
                description TEXT,
                cvss_score REAL,
                severity TEXT,
                affected_software TEXT,
                published_date TEXT,
                last_updated TEXT,
                references TEXT
            )
        ''')
        
        # Create scan templates table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scan_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                template_name TEXT UNIQUE NOT NULL,
                template_type TEXT NOT NULL,
                scan_options TEXT,
                vulnerability_types TEXT,
                port_ranges TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                created_at TEXT NOT NULL
            )
        ''')
        
        # Insert default scan templates
        default_templates = [
            ('quick_scan', 'web', 
             json.dumps({'timeout': 30, 'threads': 10}),
             json.dumps(['sql_injection', 'xss', 'csrf']),
             json.dumps([80, 443]), True, datetime.now().isoformat()),
            ('full_scan', 'comprehensive',
             json.dumps({'timeout': 60, 'threads': 20}),
             json.dumps(list(self.vulnerability_types.keys())),
             json.dumps(list(range(1, 65536))), True, datetime.now().isoformat()),
            ('port_scan', 'network',
             json.dumps({'timeout': 15, 'threads': 50}),
             json.dumps([]),
             json.dumps([21, 22, 23, 25, 53, 80, 443, 1433, 3306, 3389, 5432, 5900]),
             True, datetime.now().isoformat())
        ]
        
        cursor.executemany('''
            INSERT OR IGNORE INTO scan_templates 
            (template_name, template_type, scan_options, vulnerability_types, port_ranges, is_active, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', default_templates)
        
        conn.commit()
        conn.close()
        
    def scan_target(self, target_url: str, scan_type: str = 'quick_scan') -> str:
        """
        Start vulnerability scan on target
        Args:
            target_url: URL to scan
            scan_type: Type of scan or template name
        Returns: Scan ID
        """
        scan_id = self._generate_scan_id()
        
        # Initialize scan record
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vulnerability_scans 
            (scan_id, target_url, scan_type, start_time, created_at)
            VALUES (?, ?, ?, ?, ?)
        ''', (scan_id, target_url, scan_type, datetime.now().isoformat(), datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        # Start scan in background thread
        scan_thread = threading.Thread(
            target=self._run_vulnerability_scan,
            args=(scan_id, target_url, scan_type)
        )
        scan_thread.daemon = True
        scan_thread.start()
        
        return scan_id
        
    def _run_vulnerability_scan(self, scan_id: str, target_url: str, scan_type: str):
        """Run vulnerability scan in background"""
        try:
            vulnerabilities_found = 0
            critical_count = 0
            high_count = 0
            medium_count = 0
            low_count = 0
            
            # Parse target URL
            parsed_url = urllib.parse.urlparse(target_url)
            host = parsed_url.netloc
            path = parsed_url.path
            
            # Get scan template
            template = self._get_scan_template(scan_type)
            
            # Port scanning
            if template['port_ranges']:
                port_vulns = self._scan_ports(host, template['port_ranges'])
                for vuln in port_vulns:
                    self._record_vulnerability(scan_id, vuln)
                    vulnerabilities_found += 1
                    
                    # Update severity counts
                    if vuln['severity'] == 'critical':
                        critical_count += 1
                    elif vuln['severity'] == 'high':
                        high_count += 1
                    elif vuln['severity'] == 'medium':
                        medium_count += 1
                    else:
                        low_count += 1
                        
            # Web vulnerability scanning
            if template['vulnerability_types']:
                web_vulns = self._scan_web_vulnerabilities(target_url, template['vulnerability_types'])
                for vuln in web_vulns:
                    self._record_vulnerability(scan_id, vuln)
                    vulnerabilities_found += 1
                    
                    # Update severity counts
                    if vuln['severity'] == 'critical':
                        critical_count += 1
                    elif vuln['severity'] == 'high':
                        high_count += 1
                    elif vuln['severity'] == 'medium':
                        medium_count += 1
                    else:
                        low_count += 1
                        
            # Update scan progress
            self._update_scan_progress(scan_id, vulnerabilities_found, critical_count,
                                     high_count, medium_count, low_count)
                                     
            # Mark scan as complete
            self._complete_scan(scan_id)
            
        except Exception as e:
            self._fail_scan(scan_id, str(e))
            
    def _get_scan_template(self, template_name: str) -> Dict:
        """Get scan template configuration"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT template_type, scan_options, vulnerability_types, port_ranges
            FROM scan_templates WHERE template_name = ?
        ''', (template_name,))
        
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                'type': row[0],
                'options': json.loads(row[1]),
                'vulnerability_types': json.loads(row[2]),
                'port_ranges': json.loads(row[3])
            }
        else:
            # Default template
            return {
                'type': 'quick',
                'options': {'timeout': 30, 'threads': 10},
                'vulnerability_types': ['sql_injection', 'xss'],
                'port_ranges': [80, 443]
            }
            
    def _scan_ports(self, host: str, ports: List[int]) -> List[Dict]:
        """Scan ports for vulnerabilities"""
        vulnerabilities = []
        
        for port in ports:
            # Simulate port scan
            if self._is_port_open(host, port):
                # Check for known vulnerabilities
                if port in self.port_vulnerabilities:
                    for vuln_type in self.port_vulnerabilities[port]:
                        vuln = self._check_port_vulnerability(host, port, vuln_type)
                        if vuln:
                            vulnerabilities.append(vuln)
                            
        return vulnerabilities
        
    def _is_port_open(self, host: str, port: int) -> bool:
        """Check if port is open"""
        try:
            # Simulate port check
            return random.choice([True, True, False])  # 66% success rate
        except:
            return False
            
    def _check_port_vulnerability(self, host: str, port: int, vuln_type: str) -> Optional[Dict]:
        """Check for specific port vulnerability"""
        # Simulate vulnerability detection
        if random.choice([True, False, False, False]):  # 25% detection rate
            severity = random.choice(['critical', 'high', 'medium', 'low'])
            
            return {
                'vulnerability_type': vuln_type,
                'severity': severity,
                'cvss_score': random.uniform(3.0, 10.0),
                'cwe_id': f'CWE-{random.randint(100, 999)}',
                'description': f'{vuln_type} vulnerability on port {port}',
                'evidence': f'Detected {vuln_type} on {host}:{port}',
                'location': f'{host}:{port}',
                'remediation': f'Fix {vuln_type} vulnerability on port {port}'
            }
        return None
        
    def _scan_web_vulnerabilities(self, url: str, vuln_types: List[str]) -> List[Dict]:
        """Scan web application for vulnerabilities"""
        vulnerabilities = []
        
        for vuln_type in vuln_types:
            if vuln_type in self.vulnerability_types:
                vuln = self._check_web_vulnerability(url, vuln_type)
                if vuln:
                    vulnerabilities.append(vuln)
                    
        return vulnerabilities
        
    def _check_web_vulnerability(self, url: str, vuln_type: str) -> Optional[Dict]:
        """Check for specific web vulnerability"""
        # Simulate vulnerability detection
        if random.choice([True, False, False, False]):  # 25% detection rate
            vuln_info = self.vulnerability_types[vuln_type]
            
            return {
                'vulnerability_type': vuln_type,
                'severity': vuln_info['severity'],
                'cvss_score': vuln_info['cvss_score'],
                'cwe_id': vuln_info['cwe'],
                'description': vuln_info['description'],
                'evidence': f'Detected {vuln_type} on {url}',
                'location': url,
                'parameter': random.choice(['id', 'search', 'q', 'page', 'user']),
                'payload': self._generate_test_payload(vuln_type),
                'remediation': self._generate_remediation(vuln_type)
            }
        return None
        
    def _generate_test_payload(self, vuln_type: str) -> str:
        """Generate test payload for vulnerability"""
        payloads = {
            'sql_injection': "' OR 1=1--",
            'xss': '<script>alert("XSS")</script>',
            'csrf': 'csrf_token=invalid',
            'open_redirect': 'redirect=http://evil.com',
            'weak_ssl': 'SSLv3',
            'default_credentials': 'admin:admin',
            'outdated_software': 'Apache/2.4.1',
            'information_disclosure': 'error_log'
        }
        return payloads.get(vuln_type, 'test_payload')
        
    def _generate_remediation(self, vuln_type: str) -> str:
        """Generate remediation advice"""
        remediations = {
            'sql_injection': 'Use parameterized queries and input validation',
            'xss': 'Implement proper output encoding and CSP headers',
            'csrf': 'Implement CSRF tokens and validate requests',
            'open_redirect': 'Validate and whitelist redirect URLs',
            'weak_ssl': 'Disable weak SSL/TLS protocols and ciphers',
            'default_credentials': 'Change default passwords immediately',
            'outdated_software': 'Update to latest secure version',
            'information_disclosure': 'Remove or secure sensitive information'
        }
        return remediations.get(vuln_type, 'Implement security best practices')
        
    def _record_vulnerability(self, scan_id: str, vulnerability: Dict):
        """Record vulnerability in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vulnerabilities 
            (scan_id, vulnerability_type, severity, cvss_score, cwe_id, description,
             evidence, location, parameter, payload, remediation, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            scan_id, vulnerability['vulnerability_type'], vulnerability['severity'],
            vulnerability['cvss_score'], vulnerability['cwe_id'], vulnerability['description'],
            vulnerability['evidence'], vulnerability['location'], vulnerability.get('parameter'),
            vulnerability.get('payload'), vulnerability['remediation'], datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
        
    def _update_scan_progress(self, scan_id: str, vulnerabilities_found: int,
                            critical_count: int, high_count: int, medium_count: int, low_count: int):
        """Update scan progress"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE vulnerability_scans 
            SET vulnerabilities_found = ?, critical_count = ?, high_count = ?,
                medium_count = ?, low_count = ?
            WHERE scan_id = ?
        ''', (vulnerabilities_found, critical_count, high_count, medium_count, low_count, scan_id))
        
        conn.commit()
        conn.close()
        
    def _complete_scan(self, scan_id: str):
        """Mark scan as complete"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE vulnerability_scans 
            SET status = 'completed', end_time = ?
            WHERE scan_id = ?
        ''', (datetime.now().isoformat(), scan_id))
        
        conn.commit()
        conn.close()
        
    def _fail_scan(self, scan_id: str, error: str):
        """Mark scan as failed"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE vulnerability_scans 
            SET status = 'failed', end_time = ?
            WHERE scan_id = ?
        ''', (datetime.now().isoformat(), scan_id))
        
        conn.commit()
        conn.close()
        
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        random_suffix = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=6))
        return f"vuln_scan_{timestamp}_{random_suffix}"
        
    def get_scan_results(self, scan_id: str) -> Dict:
        """Get vulnerability scan results"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get scan info
        cursor.execute('''
            SELECT target_url, scan_type, start_time, end_time, status,
                   vulnerabilities_found, critical_count, high_count, medium_count, low_count
            FROM vulnerability_scans WHERE scan_id = ?
        ''', (scan_id,))
        
        scan_row = cursor.fetchone()
        if not scan_row:
            conn.close()
            return {'error': 'Scan not found'}
            
        scan_info = {
            'scan_id': scan_id,
            'target_url': scan_row[0],
            'scan_type': scan_row[1],
            'start_time': scan_row[2],
            'end_time': scan_row[3],
            'status': scan_row[4],
            'vulnerabilities_found': scan_row[5],
            'critical_count': scan_row[6],
            'high_count': scan_row[7],
            'medium_count': scan_row[8],
            'low_count': scan_row[9]
        }
        
        # Get vulnerabilities
        cursor.execute('''
            SELECT vulnerability_type, severity, cvss_score, cwe_id, description,
                   evidence, location, parameter, payload, remediation, false_positive, verified
            FROM vulnerabilities WHERE scan_id = ?
        ''', (scan_id,))
        
        vulnerabilities = []
        for row in cursor.fetchall():
            vulnerabilities.append({
                'vulnerability_type': row[0],
                'severity': row[1],
                'cvss_score': row[2],
                'cwe_id': row[3],
                'description': row[4],
                'evidence': row[5],
                'location': row[6],
                'parameter': row[7],
                'payload': row[8],
                'remediation': row[9],
                'false_positive': bool(row[10]),
                'verified': bool(row[11])
            })
            
        conn.close()
        
        return {
            **scan_info,
            'vulnerabilities': vulnerabilities
        }
        
    def get_all_scans(self) -> List[Dict]:
        """Get all vulnerability scans"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT scan_id, target_url, scan_type, start_time, end_time, status,
                   vulnerabilities_found, critical_count, high_count, medium_count, low_count
            FROM vulnerability_scans ORDER BY start_time DESC
        ''')
        
        scans = []
        for row in cursor.fetchall():
            scans.append({
                'scan_id': row[0],
                'target_url': row[1],
                'scan_type': row[2],
                'start_time': row[3],
                'end_time': row[4],
                'status': row[5],
                'vulnerabilities_found': row[6],
                'critical_count': row[7],
                'high_count': row[8],
                'medium_count': row[9],
                'low_count': row[10]
            })
            
        conn.close()
        return scans
        
    def mark_false_positive(self, vulnerability_id: int) -> bool:
        """Mark vulnerability as false positive"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                UPDATE vulnerabilities 
                SET false_positive = TRUE
                WHERE id = ?
            ''', (vulnerability_id,))
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            print(f"Error marking false positive: {e}")
            return False
            
    def verify_vulnerability(self, vulnerability_id: int) -> bool:
        """Mark vulnerability as verified"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                UPDATE vulnerabilities 
                SET verified = TRUE
                WHERE id = ?
            ''', (vulnerability_id,))
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            print(f"Error verifying vulnerability: {e}")
            return False
            
    def get_vulnerability_statistics(self) -> Dict:
        """Get vulnerability statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT COUNT(*) FROM vulnerability_scans')
        total_scans = cursor.fetchone()[0]
        
        cursor.execute('SELECT COUNT(*) FROM vulnerabilities')
        total_vulnerabilities = cursor.fetchone()[0]
        
        cursor.execute('''
            SELECT severity, COUNT(*) 
            FROM vulnerabilities 
            GROUP BY severity
        ''')
        vulnerabilities_by_severity = dict(cursor.fetchall())
        
        cursor.execute('''
            SELECT vulnerability_type, COUNT(*) 
            FROM vulnerabilities 
            GROUP BY vulnerability_type
        ''')
        vulnerabilities_by_type = dict(cursor.fetchall())
        
        cursor.execute('SELECT COUNT(*) FROM vulnerabilities WHERE false_positive = TRUE')
        false_positives = cursor.fetchone()[0]
        
        cursor.execute('SELECT COUNT(*) FROM vulnerabilities WHERE verified = TRUE')
        verified_vulnerabilities = cursor.fetchone()[0]
        
        conn.close()
        
        return {
            'total_scans': total_scans,
            'total_vulnerabilities': total_vulnerabilities,
            'vulnerabilities_by_severity': vulnerabilities_by_severity,
            'vulnerabilities_by_type': vulnerabilities_by_type,
            'false_positives': false_positives,
            'verified_vulnerabilities': verified_vulnerabilities,
            'last_updated': datetime.now().isoformat()
        } 